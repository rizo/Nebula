(** Interrupt handling.

    Interrupts generated by hardware or by the [INT] instructions are placed in
    a FIFO queue. Interrupt dequeuing can be enabled and disabled on-demand.

    The interrupt controller can maintain a single interrupt trigger at any one
    time.

    For more information on interrupts, see {! Interrupt}.

    @author Jesse Haber-Kucharsky
    @see 'LICENSE' License details *)

(** The interrupt controller state. *)
type t

(** The controller in an empty state with no trigger and an empty queue.

    Interrupt dequeing is initially enabled. *)
val empty : t

(** The maximum number of interrupts that can be queued before a fatal error. *)
val max_queued_interrupts : int

(** Raised when the number of interrupts exceeds {! max_queued_interrupts}. *)
exception Caught_fire

(** Enqueue a new interrupt from an external source. *)
val enqueue : Interrupt.t -> t -> t

(** Dequeue the next received interrupt from the queue, if there is one and if
    dequeuing is enabled. *)
val handle : t -> (Interrupt.t * t) option

(** Set a new interrupt trigger.

    Only one interrupt trigger can be set at once. *)
val trigger : Interrupt.Trigger.t -> t -> t

(** The current interrupt trigger, if one has been set via {! trigger}.

    Once a trigger has been viewed in this way, it will no longer be set. *)
val triggered : t -> (Interrupt.Trigger.t * t) option

(** Whether or not interrupts are being dequeued during execution. *)
val dequeuing : t -> bool

(** Enable interrupt dequeuing. *)
val enable_dequeuing :  t -> t

(** Disable interrupt dequeuing. *)
val disable_dequeuing : t -> t
