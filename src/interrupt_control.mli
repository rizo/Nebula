(** Interrupt handling.

    Interrupts generated by hardware or by the [INT] instructions are placed in
    a FIFO queue. Interrupt dequeuing can be enabled and disabled on-demand.

    @author Jesse Haber-Kucharsky
    @see 'LICENSE' License details *)

(** The interrupt controller state. *)
type t

(** The controller in an empty state with no trigger and an empty queue.

    Interrupt dequeing is initially enabled. *)
val empty : t

(** The maximum number of interrupts that can be queued before a fatal error. *)
val max_queued_interrupts : int

(** Raised when the number of interrupts exceeds {! max_queued_interrupts}. *)
exception Caught_fire

(** Enqueue a new interrupt from an external source. *)
val enqueue : Interrupt.t -> t -> t

(** Dequeue the next received interrupt from the queue, if there is one and if
    dequeuing is enabled. *)
val handle : t -> (Interrupt.t * t) option

(** Trigger an interrupt.

    Interrupts will most often be triggered after they have been dequeued via {!
    handle}.

    Only one interrupt can be triggered at once. *)
val trigger : Interrupt.Trigger.t -> t -> t

(** The currently triggered interrupt, if there is one.

    Once a triggered interrupt has been viewed in this way, it will no longer be
    triggered. *)
val triggered : t -> (Interrupt.Trigger.t * t) option

(** Whether or not interrupts are being dequeued during execution. *)
val dequeuing : t -> bool

(** Enable interrupt dequeuing. *)
val enable_dequeuing :  t -> t

(** Disable interrupt dequeuing. *)
val disable_dequeuing : t -> t
